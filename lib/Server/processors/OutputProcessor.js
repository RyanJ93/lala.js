'use strict';

// Including native modules.
const { Readable } = require('stream');
const zlib = require('zlib');

// Including Lala's modules.
const Processor = require('./Processor');
const HTTPSerializer = require('../support/HTTPSerializer');
const Context = require('../../Types/Context');
const {
    InvalidArgumentException,
    NotAcceptableHTTPException
} = require('../../Exceptions');

/**
 * @typedef {Object} CompressionAlgorithmMap Represents the usage settings defined for each supported compression algorithm.
 *
 * @property {boolean} [gzip=true] If set to "true" it means that if a client accepts GZip compression, it will be considered as compression algorithm for response, behind deflate and Brotli.
 * @property {boolean} [deflate=true] If set to "true" it means that if a client accepts Deflate compression, it will be considered behind the Brotli algorithm.
 * @property {boolean} [brotli=true] If set to "true" it means that if a client accepts Brotli compression it will be used as the first candidate, over Deflate and GZip.
 */

/**
 * @typedef {Object} CompressionAlgorithmCandidate Represents the compression algorithm that is intended to be used and the related encoding name.
 *
 * @property {(BrotliCompress|Deflate|Gzip)} compressor An instance of the class representing the chosen stream.
 * @property {string} contentEncoding A string containing the encoding name corresponding to the compression algorithm that is going to be used.
 */

/**
 * @typedef {Object} OutputProcessorConfiguration An object containing all the properties supported by this class.
 *
 * @property {?Context} context An instance of the class "Context" representing current client connection context containing both the request and response streams.
 * @property {boolean} [GZipCompressionEnabled=true] If set to "true" the Gzip compression algorithm can be used to compress client response.
 * @property {boolean} [deflateCompressionEnabled=true] If set to "true" the Deflate compression algorithm can be used to compress client response.
 * @property {boolean} [BrotliCompressionEnabled=true] If set to "true" the Brotli compression algorithm can be used to compress client response.
 * @property {boolean} [compression=true] If set to "true" and if at least one supported compression algorithm is given by the client, client response will be compressed.
 * @property {?Context} context An instance of the class "Context" representing current client request and containing both the request and the response object generated by the server.
 * @property {boolean} [stealth=false] If set to "true", identification headers such as "X-Powered-By" will be omitted in client response.
 */

/**
 * This class allows to convert an arbitrary value into a readable stream that can be sent to the client.
 */
class OutputProcessor extends Processor {
    /**
     * Returns all the properties supported by this class and their default values.
     *
     * @returns {OutputProcessorConfiguration} An object containing as key the property name and as value its default value.
     *
     * @override
     */
    static getDefaultConfiguration(){
        return {
            GZipCompressionEnabled: true,
            deflateCompressionEnabled: true,
            BrotliCompressionEnabled: true,
            compression: true,
            context: null,
            stealth: false
        };
    }

    /**
     * Returns the available compression algorithms according to internal settings and current request context (protocol and content type).
     *
     * @returns {Object.<string, number>} An object having as key the algorithm name and as value the preference score.
     *
     * @protected
     */
    _getSupportedCompressionAlgorithms(){
        const supportedEncodings = {};
        if ( this._compression === true ){
            const contentType = typeof this._headers['Content-Type'] === 'string' ? this._headers['Content-Type'] : this._contentType;
            // Check if response is already a compressed entity.
            if ( OutputProcessor.COMPRESSED_ENTITY_CONTENT_TYPES.indexOf(contentType) === -1 ){
                // Brotli requires the HTTPS protocol to be in use.
                if ( this._compressionAlgorithmMap.brotli === true && this._context.getRequest().secure === true ){
                    supportedEncodings.br = 1;
                }
                if ( this._compressionAlgorithmMap.deflate === true ){
                    supportedEncodings.deflate = 0.75;
                }
                if ( this._compressionAlgorithmMap.gzip === true ){
                    supportedEncodings.gzip = 0.5;
                }
            }
        }
        return supportedEncodings;
    }

    /**
     * Returns the best compression algorithm that can be used according to client provided preferences, internal settings and current request context.
     *
     * @returns {?string} A string containing the name of the compression algorithm to use or null if no algorithm has been found.
     *
     * @protected
     */
    _getBestCompressionAlgorithm(){
        // Get all the supported algorithms according to internal settings and current request context.
        const supportedAlgorithms = this._getSupportedCompressionAlgorithms();
        // Extract a plain list from the object, list must be ordered by algorithm score.
        const supportedEncodingsList = Object.keys(supportedAlgorithms);
        const acceptedEncodings = [], acceptedEncodingsList = [], ignoreList = [];
        let wildcardEnabled = false, wildcardScore = null;
        let acceptEncoding = this._context.getRequest().headers['accept-encoding'];
        acceptEncoding = acceptEncoding !== '' && typeof acceptEncoding === 'string' ? acceptEncoding.replace(/\s/g, '') : null;
        // By default uncompressed output is always accepted, check if it has been disabled by the client.
        let identityAllowed = acceptEncoding === null || acceptEncoding.indexOf('identity;q=0') === -1;
        // Set the best algorithm available as the default choice.
        let algorithm = acceptEncoding !== null && supportedEncodingsList.length > 0 ? supportedEncodingsList[0] : null;
        if ( algorithm !== null && acceptEncoding !== null && acceptEncoding !== '*' ){
            // If an accept encoding string has been found, extract algorithms from it.
            const encodings = acceptEncoding.split(',');
            const length = encodings.length;
            for ( let i = 0 ; i < length ; i++ ){
                // Separate the algorithm name from its score.
                const index = encodings[i].indexOf(';');
                const encoding = index === -1 ? encodings[i] : encodings[i].substr(0, index);
                let score;
                if ( index === -1 ){
                    // If current algorithm is not supported set its score to null in order to ignore it later.
                    score = supportedAlgorithms.hasOwnProperty(encoding) ? supportedAlgorithms[encoding] : null;
                }else{
                    // Remove the "q=" prefix and get the score as a number.
                    score = parseFloat(encodings[i].substr(index + 3));
                }
                if ( encoding === '*' ){
                    // Current encoding is the "*" wildcard, if its score is zero then it means that algorithm selection must be strict.
                    wildcardEnabled = score > 0;
                    wildcardScore = score;
                }else if ( score !== null && score <= 0 ){
                    // This algorithm's score is 0, it mustn't be used.
                    ignoreList.push(encoding);
                }else if ( supportedAlgorithms.hasOwnProperty(encoding) && acceptedEncodingsList.indexOf(encoding) === -1 ){
                    // This is an algorithm accepted by both the client and the server side, add it to the candidate list.
                    acceptedEncodings.push([encoding, score]);
                    acceptedEncodingsList.push(encoding);
                }
            }
            if ( wildcardEnabled ){
                // Wildcard is enabled, server can pick the best algorithm but this choice will have the same score assigned to the wildcard.
                let alternativeEncoding = null, alternativeEncodingScore = null, i = 0;
                // Iterate all the supported algorithms ordered by their score.
                while ( alternativeEncoding === null && i < supportedEncodingsList.length ){
                    if ( acceptedEncodingsList.indexOf(supportedEncodingsList[i]) === -1 && ignoreList.indexOf(supportedEncodingsList[i]) === -1 ){
                        // Current algorithm has not been suggested by the client nor banned by the client, use it as an alternative algorithm.
                        alternativeEncoding = supportedEncodingsList[i];
                        alternativeEncodingScore = supportedAlgorithms[supportedEncodingsList[i]];
                    }
                    i++;
                }
                if ( alternativeEncoding !== null ){
                    // An alternative algorithm has been found, add it to the list of accepted algorithms assigning the same score assigned to the wildcard.
                    const score = wildcardScore === null ? alternativeEncodingScore : wildcardScore;
                    acceptedEncodings.push([alternativeEncoding, score]);
                }
            }
            // Order the list of all the accepted algorithms by their score, then pick the first one.
            algorithm = acceptedEncodings.length === 0 ? null : acceptedEncodings.sort((a, b) => {
                return a[1] <= b[1] ? 1 : -1;
            })[0][0];
        }
        // If no algorithm has been found returns that no compression should be applied, is uncompressed output is disabled, return null.
        return identityAllowed && algorithm === null ? 'identity' : algorithm;
    }

    /**
     * Generates the stream to use to compress data to send to the client according to defined settings and client accepted algorithms.
     *
     * @returns {?CompressionAlgorithmCandidate} An object containing both the compression stream and the related Content-Encoding HTTP header, if no eligible algorithm is found, null is returned instead.
     *
     * @protected
     */
    _createCompressionStream(){
        let candidate = null;
        switch ( this._getBestCompressionAlgorithm() ){
            case 'br': {
                candidate = {
                    compressor: zlib.createBrotliCompress(),
                    contentEncoding: 'br'
                };
            }break;
            case 'deflate': {
                candidate = {
                    compressor: zlib.createDeflate(),
                    contentEncoding: 'deflate'
                };
            }break;
            case 'gzip': {
                candidate = {
                    compressor: zlib.createGzip(),
                    contentEncoding: 'gzip'
                };
            }break;
            case null: {
                throw new NotAcceptableHTTPException('No available encoding found.', 1);
            }
        }
        return candidate;
    }

    /**
     * Adds some additional headers to the client response according to current settings.
     *
     * @protected
     */
    _prepareHeaders(){
        if ( this._stealth !== true ){
            this._headers['X-Powered-By'] = 'Lala.js';
        }
        if ( !this._headers.hasOwnProperty('Content-Type') ){
            this._headers['Content-Type'] = this._contentType === null ? OutputProcessor.DEFAULT_CONTENT_TYPE : this._contentType;
        }
    }

    /**
     * Serializes given data into a stream that can be sent to the client as a response.
     *
     * @param {*} data Some data to serialize.
     *
     * @returns {Promise<?module:stream.internal.Readable>} A stream representing the serialized data.
     *
     * @protected
     */
    async _serialize(data){
        // Initialize the serializer.
        const serializer = new HTTPSerializer();
        // Setup current request context parameters to use if a callback is given.
        const callbackParameters = this._context === null ? [null, null] : [this._context.getRequest(), this._context.getResponse()];
        serializer.setContext(this._context).setCallbackParameters(callbackParameters);
        // Generate the serialized stream.
        const serialization = await serializer.serialize(data);
        // Get MIME type detected.
        this._contentType = serializer.getContentType();
        return serialization;
    }

    /**
     * The class constructor.
     *
     * @param {?OutputProcessorConfiguration} [configuration=null] An object containing the values for class properties.
     */
    constructor(configuration = null){
        super(configuration);

        /**
         * @type {?Context} _context An object representing current client request and containing both the request and the response object generated by the server.
         *
         * @protected
         */
        this._context = null;

        /**
         * @type {CompressionAlgorithmMap} _compressionAlgorithmMap An object containing the usage settings for each the supported algorithms.
         *
         * @protected
         */
        this._compressionAlgorithmMap = {
            gzip: true,
            deflate: true,
            brotli: true
        };

        /**
         * @type {boolean} _compression If set to "true", a compression layer will be applied over the response stream.
         *
         * @protected
         */
        this._compression = true;

        /**
         * @type {string} _contentType A string containing the output's MIME type to declare that has been detected.
         *
         * @protected
         */
        this._contentType = OutputProcessor.DEFAULT_CONTENT_TYPE;

        /**
         * @type {Object.<string, string>} _headers An object containing all the HTTP headers that will be sent to the client once the response is ready and right to be sent.
         *
         * @protected
         */
        this._headers = {};

        /**
         * @type {boolean} [_stealth=false] If set to "true", identification headers such as "X-Powered-By" will be omitted in client response.
         *
         * @protected
         */
        this._stealth = false;

        if ( configuration !== null && typeof configuration === 'object' ){
            // Setup internal properties.
            this.configure(configuration);
        }
    }

    /**
     * Configures internal properties based on the configuration object given, this method is chainable.
     *
     * @param {OutputProcessorConfiguration} configuration An object containing the values for class properties.
     *
     * @returns {OutputProcessor}
     *
     * @throws {InvalidArgumentException} If an invalid configuration object is given.
     *
     * @override
     */
    configure(configuration){
        if ( configuration === null || typeof configuration !== 'object' ){
            throw new InvalidArgumentException('Invalid configuration object.', 1);
        }
        if ( configuration.hasOwnProperty('context') && configuration.context instanceof Context ){
            this._context = configuration.context;
        }
        this._compressionAlgorithmMap.gzip = !configuration.hasOwnProperty('GZipCompressionEnabled') || configuration.GZipCompressionEnabled !== false;
        this._compressionAlgorithmMap.deflate = !configuration.hasOwnProperty('deflateCompressionEnabled') || configuration.deflateCompressionEnabled !== false;
        this._compressionAlgorithmMap.brotli = !configuration.hasOwnProperty('BrotliCompressionEnabled') || configuration.BrotliCompressionEnabled !== false;
        this._compression = !configuration.hasOwnProperty('compression') || configuration.compression !== false;
        this._stealth = configuration.hasOwnProperty('stealth') && configuration.stealth === true;
        return this;
    }

    /**
     * Updates current request context by setting new streams for both client request and response, this method is chainable.
     *
     * @param {module:http.IncomingMessage} request An instance of the built-in class "IncomingMessage" containing all the connection properties.
     * @param {module:http.ServerResponse} response An instance of the built-in class "ServerResponse" representing the response that will be sent back to the client.
     *
     * @returns {OutputProcessor}
     *
     * @throws {InvalidArgumentException} If an invalid object is given as request object.
     * @throws {InvalidArgumentException} If an invalid object is given as response object.
     */
    updateContext(request, response){
        if ( request === null || typeof request !== 'object' ){
            throw new InvalidArgumentException('Invalid request object.', 1);
        }
        if ( response === null || typeof response !== 'object' ){
            throw new InvalidArgumentException('Invalid response object.', 2);
        }
        this._context = new Context(request, response);
        return this;
    }

    /**
     * Returns the MIME type detected according to defined data.
     *
     * @returns {string} A string representing the MIME type detected, by default, "text/html" is used.
     */
    getDetectedContentType(){
        return this._contentType;
    }

    /**
     * Generates a readable stream from a string serialization obtained from some given data.
     *
     * @param {module:http.IncomingMessage} request An instance of the built-in class "IncomingMessage" containing all the connection properties.
     * @param {module:http.ServerResponse} response An instance of the built-in class "ServerResponse" representing the response that will be sent back to the client.
     *
     * @async
     */
    async process(request, response){
        let output = response.hasOwnProperty('rawOutput') ? await this._serialize(response.rawOutput) : null;
        if ( output === null ){
            // Generate and empty stream.
            output = new Readable();
            output.push(null);
        }
        // Send the generated response to the client if no output has been made so far.
        if ( !response.headersSent ){
            // Get the compression algorithm to apply to the response.
            const compression = this._createCompressionStream();
            // Add all the other HTTP headers required according to internal settings.
            this._prepareHeaders();
            if ( compression !== null ){
                // Add compression related HTTP headers, if compression is available.
                this._headers['Vary'] = 'Accept-Encoding';
                this._headers['Content-Encoding'] = compression.contentEncoding;
            }
            const code = response.statusCode > 0 ? response.statusCode : 200;
            const message = response.hasOwnProperty('statusMessage') && response.statusMessage !== '' && typeof response.statusMessage === 'string' ? response.statusMessage : 'Found.';
            // Write the response head.
            response.writeHead(code, message, this._headers);
            if ( compression !== null ){
                // Apply compression.
                output = output.pipe(compression.compressor);
            }
            // Flush the output generated to the client.
            output.pipe(response);
        }
    }
}

/**
 * @constant Contains the list of all the MIME types used by compressed responses.
 *
 * @type {string[]}
 * @default
 */
Object.defineProperty(OutputProcessor, 'COMPRESSED_ENTITY_CONTENT_TYPES', {
    value: ['application/x-rar-compressed', 'application/zip', 'application/x-zip-compressed', 'multipart/x-zip', 'application/x-brotli', 'application/gzip'],
    writable: false,
    configurable: true,
    enumerable: true
});

/**
 * @constant Contains the default MIME type used for the Content-Type header.
 *
 * @type {string}
 * @default
 */
Object.defineProperty(OutputProcessor, 'DEFAULT_CONTENT_TYPE', {
    value: 'text/html',
    writable: false,
    configurable: true,
    enumerable: true
});

module.exports = OutputProcessor;
