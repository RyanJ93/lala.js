'use strict';

// Including native modules.
const { Readable } = require('stream');
const zlib = require('zlib');

// Including Lala's modules.
const Processor = require('./Processor');
const Response = require('../responses/Response');
const View = require('../../View/View');
const Context = require('../../Types/Context');
const {
    RuntimeException
} = require('../../Exceptions');

/**
 * Represents the usage settings defined for each supported compression algorithm.
 *
 * @typedef {Object} CompressionAlgorithmMap

 * @property {boolean} [gzip=true] If set to "true" it means that if a client accepts GZip compression, it will be considered as compression algorithm for response, behind deflate and Brotli.
 * @property {boolean} [deflate=true] If set to "true" it means that if a client accepts Deflate compression, it will be considered behind the Brotli algorithm.
 * @property {boolean} [brotli=true] If set to "true" it means that if a client accepts Brotli compression it will be used as the first candidate, over Deflate and GZip.
 */

/**
 * Represents the compression algorithm that is intended to be used and the related encoding name.
 *
 * @typedef {Object} CompressionAlgorithmCandidate
 *
 * @property {(BrotliCompress|Deflate|Gzip)} compressor An instance of the class representing the chosen stream.
 * @property {string} contentEncoding A string containing the encoding name corresponding to the compression algorithm that is going to be used.
 */

/**
 * @typedef OutputProcessorConfiguration An object containing all the properties supported by this class.
 *
 * @property {?Context} context An instance of the class "Context" representing current client connection context containing both the request and response streams.
 * @property {boolean} [GZipCompressionEnabled=true] If set to "true" the Gzip compression algorithm can be used to compress client response.
 * @property {boolean} [deflateCompressionEnabled=true] If set to "true" the Deflate compression algorithm can be used to compress client response.
 * @property {boolean} [BrotliCompressionEnabled=true] If set to "true" the Brotli compression algorithm can be used to compress client response.
 * @property {boolean} [compression=true] If set to "true" and if at least one supported compression algorithm is given by the client, client response will be compressed.
 * @property {?Context} context An instance of the class "Context" representing current client request and containing both the request and the response object generated by the server.
 */

/**
 * This class allows to convert an arbitrary value into a readable stream that can be sent to the client.
 */
class OutputProcessor extends Processor {
    /**
     * Serializes some given data into a string representation that can be sent to the client.
     *
     * @param {*} data Some data to serialize and prepare for sending.
     *
     * @returns {Promise<?module:stream.internal.Readable>} A readable stream representing the final output to send to the client.
     *
     * @protected
     */
    async _processData(data){
        let output = null;
        if ( data !== null && typeof data !== 'undefined' ){
            switch ( typeof data ){
                case 'boolean':
                case 'number':
                case 'bigint':
                case 'string': {
                    output = this._processPrimitive(data);
                }break;
                case 'object': {
                    output = await this._processObject(data);
                }break;
                case 'function': {
                    output = await this._processCallback(data);
                }break;
            }
        }
        return output;
    }

    /**
     * Generates the stream to use to compress data to send to the client according to defined settings and client accepted algorithms.
     *
     * @param {module:http.IncomingMessage} request An instance of the built-in class "IncomingMessage" containing all the connection properties.
     *
     * @returns {?CompressionAlgorithmCandidate} An object containing both the compression stream and the related Content-Encoding HTTP header, if no eligible algorithm is found, null is returned instead.
     *
     * @protected
     */
    _createCompressionStream(request){
        const acceptEncoding = request.headers['accept-encoding'];
        let candidate = null;
        if ( acceptEncoding !== '' && typeof acceptEncoding === 'string' && this._compression !== false ){
            if ( this._compressionAlgorithmMap.brotli === true && acceptEncoding.indexOf(' br') !== -1 && typeof zlib.createBrotliCompress === 'function' ){
                candidate = {
                    compressor: zlib.createBrotliCompress(),
                    contentEncoding: 'br'
                };
            }
            if ( this._compressionAlgorithmMap.deflate === true && acceptEncoding.indexOf(' deflate') !== -1 ){
                candidate = {
                    compressor: zlib.createDeflate(),
                    contentEncoding: 'deflate'
                };
            }
            if ( this._compressionAlgorithmMap.gzip === true && acceptEncoding.indexOf(' gzip') !== -1 ){
                candidate = {
                    compressor: zlib.createGzip(),
                    contentEncoding: 'gzip'
                };
            }
        }
        return candidate;
    }

    /**
     * Generates a string representation for a given primitive value.
     *
     * @param {*} data The primitive value that will be converted, such as a number, a boolean value, an integer number in arbitrary precision or a string.
     *
     * @returns {module:stream.internal.Readable} A readable stream representing the given primitive value.
     *
     * @protected
     */
    _processPrimitive(data){
        // Primitive values are sent as a string representation.
        data = typeof data === 'string' ? data : data.toString();
        const stream = new Readable();
        stream.push(data);
        stream.push(null);
        return stream;
    }

    /**
     * Generates a string representation based on a given object.
     *
     * @param {*} obj An arbitrary object that will be converted into a string representation.
     *
     * @returns {Promise<?module:stream.internal.Readable>} A readable stream representing the given object.
     *
     * @throws {RuntimeException} If an instance of the class "Response" is being processed but no request context has been defined.
     *
     * @async
     * @protected
     */
    async _processObject(obj){
        let output = null;
        if ( obj instanceof View ){
            // Render the view and returns the compiled HTML content.
            output = await obj.renderAsStream();
        }else if ( obj instanceof Response ) {
            // Applies patches from the returned response according to its implementation.
            if ( this._context === null ){
                throw new RuntimeException('Unable to apply the response object as no context has been defined.', 1);
            }
            const data = output = await obj.apply(this._context.getRequest(), this._context.getResponse());
            if ( output !== null && !( output instanceof Readable ) ){
                // Process output from response object in order to convert it into a readable stream.
                output = await this._processData(data);
            }
        }else if ( obj instanceof Readable ){
            // Just return given data as it is already a readable stream.
            output = obj;
        }else{
            // Return a JSON representation of the object.
            const serialization = JSON.stringify(obj);
            // Generate a readable stream from the string serialization.
            output = new Readable();
            output.push(serialization);
            output.push(null);
            // Set the proper content type signature for a JSON response.
            this._contentType = 'application/json';
        }
        return output;
    }

    /**
     * Generates a string representation based on the value returned by the given callback function.
     *
     * @param {function} callback An arbitrary callback function to execute.
     *
     * @returns {Promise<?module:stream.internal.Readable>} A readable stream representing the output obtained from the given callback function.
     *
     * @async
     * @protected
     */
    async _processCallback(callback){
        // Execute the function and then re-process its output.
        const data = this._context === null ? await callback(null, null) : await callback(this._context.getRequest(), this._context.getResponse());
        // Process returned data in order to generate the final stream representation.
        return await this._processData(data);
    }

    /**
     * Applies the compression layer chosen according to compression settings defined.
     *
     * @param {module:stream.internal.Readable} output The readable stream representing the output that is going to be sent back to the client.
     *
     * @protected
     */
    _applyCompression(output){
        // Get the compression stream generated according to compression settings defined.
        const compression = this._createCompressionStream(this._context.getRequest());
        if ( compression !== null ){
            // Set headers to indicate to the client what compression algorithm is going to be used.
            this._headers['Vary'] = 'Accept-Encoding';
            this._headers['Content-Encoding'] = compression.contentEncoding;
            // Apply compression.
            output.pipe(compression.compressor);
        }
    }

    /**
     * Returns all the properties supported by this class and their default values.
     *
     * @returns {OutputProcessorConfiguration} An object containing as key the property name and as value its default value.
     *
     * @override
     */
    static getDefaultConfiguration(){
        return {
            GZipCompressionEnabled: true,
            deflateCompressionEnabled: true,
            BrotliCompressionEnabled: true,
            compression: true,
            context: null
        };
    }

    /**
     * The class constructor.
     *
     * @param {?OutputProcessorConfiguration} [configuration=null] An object containing the values for class properties.
     */
    constructor(configuration = null){
        super(configuration);

        /**
         * @type {?Context} _context An object representing current client request and containing both the request and the response object generated by the server.
         *
         * @protected
         */
        this._context = null;

        /**
         * @type {CompressionAlgorithmMap} _compressionAlgorithmMap An object containing the usage settings for each the supported algorithms.
         *
         * @protected
         */
        this._compressionAlgorithmMap = {
            gzip: true,
            deflate: true,
            brotli: true
        };

        /**
         * @type {boolean} _compression If set to "true", a compression layer will be applied over the response stream.
         *
         * @protected
         */
        this._compression = true;

        /**
         * @type {string} _contentType A string containing the output's MIME type to declare that has been detected.
         *
         * @protected
         */
        this._contentType = 'text/html';

        /**
         * @type {Object.<string, string>} _headers An object containing all the HTTP headers that will be sent to the client once the response is ready and right to be sent.
         *
         * @protected
         */
        this._headers = {};

        if ( configuration !== null && typeof configuration === 'object' ){
            // Setup internal properties.
            this.configure(configuration);
        }
    }

    /**
     * Configures internal properties based on the configuration object given, this method is chainable.
     *
     * @param {OutputProcessorConfiguration} configuration An object containing the values for class properties.
     *
     * @returns {OutputProcessor}
     *
     * @throws {InvalidArgumentException} If an invalid configuration object is given.
     *
     * @override
     */
    configure(configuration){
        if ( configuration === null || typeof configuration !== 'object' ){
            throw new InvalidArgumentException('Invalid configuration object.', 1);
        }
        if ( configuration.hasOwnProperty('context') && configuration.context instanceof Context ){
            this._context = configuration.context;
        }
        this._compressionAlgorithmMap.gzip = !configuration.hasOwnProperty('GZipCompressionEnabled') || configuration.GZipCompressionEnabled !== false;
        this._compressionAlgorithmMap.deflate = !configuration.hasOwnProperty('deflateCompressionEnabled') || configuration.deflateCompressionEnabled !== false;
        this._compressionAlgorithmMap.brotli = !configuration.hasOwnProperty('BrotliCompressionEnabled') || configuration.BrotliCompressionEnabled !== false;
        this._compression = !configuration.hasOwnProperty('compression') || configuration.compression !== false;
        return this;
    }

    /**
     * Updates current request context by setting new streams for both client request and response, this method is chainable.
     *
     * @param {module:http.IncomingMessage} request An instance of the built-in class "IncomingMessage" containing all the connection properties.
     * @param {module:http.ServerResponse} response An instance of the built-in class "ServerResponse" representing the response that will be sent back to the client.
     *
     * @returns {OutputProcessor}
     *
     * @throws {InvalidArgumentException} If an invalid object is given as request object.
     * @throws {InvalidArgumentException} If an invalid object is given as response object.
     */
    updateContext(request, response){
        if ( request === null || typeof request !== 'object' ){
            throw new InvalidArgumentException('Invalid request object.', 1);
        }
        if ( response === null || typeof response !== 'object' ){
            throw new InvalidArgumentException('Invalid response object.', 2);
        }
        this._context = new Context(request, response);
        return this;
    }

    /**
     * Returns the MIME type detected according to defined data.
     *
     * @returns {string} A string representing the MIME type detected, by default, "text/html" is used.
     */
    getDetectedContentType(){
        return this._contentType;
    }

    /**
     *
     *
     * @protected
     */
    _prepareHeaders(){
        this._headers = {};
        this._headers['X-Powered-By'] = 'Lala.js';
    }

    /**
     * Generates a readable stream from a string serialization obtained from some given data.
     *
     * @param {module:http.IncomingMessage} request An instance of the built-in class "IncomingMessage" containing all the connection properties.
     * @param {module:http.ServerResponse} response An instance of the built-in class "ServerResponse" representing the response that will be sent back to the client.
     *
     * @async
     */
    async process(request, response){
        let output = response.hasOwnProperty('rawOutput') ? await this._processData(response.rawOutput) : null;
        if ( output === null ){
            //
            output = new Readable();
            output.push(null);
        }
        //
        this._prepareHeaders();
        //
        if ( !response.headersSent ){
            this._headers['Content-Type'] = this._contentType;
            //
            const code = response.hasOwnProperty('statusCode') && response.statusCode !== null && !isNaN(response.statusCode) ? response.statusCode : 200;
            const message = response.hasOwnProperty('statusMessage') && response.statusMessage !== '' && typeof response.statusMessage === 'string' ? response.statusMessage : 'Found.';
            response.writeHead(code, message, this._headers);
            // Apply compression defined by making the output stream flush in the compression one.
            this._applyCompression(output);
            //
            output.pipe(response);
        }
    }
}

module.exports = OutputProcessor;
